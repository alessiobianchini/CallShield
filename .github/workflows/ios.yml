name: iOS Build (React Native)

on:
  workflow_dispatch:

env:
  NODE_VERSION: "20"
  WORKING_DIRECTORY: .
  IOS_WORKSPACE: ios/callshieldnative.xcworkspace
  IOS_SCHEME: callshieldnative
  ARCHIVE_PATH: build/CallShield.xcarchive
  EXPORT_PATH: build/ipa
  BUILD_NUMBER: ${{ github.run_number }}
  PNPM_STORE_PATH: /Users/runner/.pnpm-store
  EXPO_PUBLIC_API_BASE_URL: ${{ secrets.BASE_URL }}
  EXPO_PUBLIC_FUNCTION_KEY: ${{ secrets.FUNCTION_KEY }}

jobs:
  build-ios:
    runs-on: macos-latest
    environment: IOS

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # NOT REMOVE!
      - name: Install pnpm
        run: npm install -g pnpm

      - name: Precreate pnpm store dir (for setup-node cache)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${{ env.PNPM_STORE_PATH }}"
          pnpm config set store-dir "${{ env.PNPM_STORE_PATH }}"
          echo "pnpm store configured and precreated at: ${{ env.PNPM_STORE_PATH }}"

      - name: Setup Node (with pnpm cache)
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: pnpm
          cache-dependency-path: pnpm-lock.yaml

      - name: Enable corepack + pin pnpm
        shell: bash
        run: |
          set -euo pipefail
          corepack enable
          corepack prepare pnpm@9 --activate
          pnpm --version

      - name: Ensure cache dirs exist
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${{ env.PNPM_STORE_PATH }}"
          mkdir -p "$HOME/Library/Caches/CocoaPods" "$HOME/.cocoapods"
          echo "pnpm store-dir: $(pnpm config get store-dir 2>/dev/null || true)"
          echo "Ensured cache dirs exist."

      - name: Ensure pnpm store dir exists (fix setup-node post cache)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${{ env.PNPM_STORE_PATH }}"
          pnpm config set store-dir "${{ env.PNPM_STORE_PATH }}"
          echo "pnpm store-dir: $(pnpm config get store-dir)"
          echo "pnpm store path: $(pnpm store path)"
          ls -la "${{ env.PNPM_STORE_PATH }}" || true

      - name: Install JS dependencies
        working-directory: ${{ env.WORKING_DIRECTORY }}
        shell: bash
        run: |
          set -euo pipefail
          pnpm install --no-frozen-lockfile

      - name: Ensure extension sources exist (Call Directory)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ios/CallShieldDirectory

      - name: Install XcodeGen
        shell: bash
        run: |
          set -euo pipefail
          brew install xcodegen

      - name: Generate Xcode project (app + Call Directory extension)
        shell: bash
        working-directory: ${{ env.WORKING_DIRECTORY }}
        run: |
          set -euo pipefail
          echo "Spec at: $(pwd)/project.yml"
          ls -la ios || true
          ls -la ios/CallShieldDirectory || true
          ls -la ios/callshieldnative || true
          xcodegen generate --spec project.yml

      - name: Install provisioning profiles (app + extension)
        shell: bash
        env:
          IOS_PROVISION_PROFILE: ${{ secrets.IOS_PROVISION_PROFILE }}
          IOS_PROVISION_PROFILE_DIR: ${{ secrets.IOS_PROVISION_PROFILE_DIR }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          decode() {
            local val="$1"
            local name="$2"
            if [ -n "$val" ]; then
              printf '%s' "$val" | base64 --decode > "$HOME/Library/MobileDevice/Provisioning Profiles/$name.mobileprovision"
              echo "Installed profile: $name"
            fi
          }
          decode "$IOS_PROVISION_PROFILE" "dist"
          decode "$IOS_PROVISION_PROFILE_DIR" "callshielddirectory"

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/CocoaPods
            ~/.cocoapods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install CocoaPods
        working-directory: ${{ env.WORKING_DIRECTORY }}/ios
        shell: bash
        run: |
          set -euo pipefail
          pod --version

          pod install --repo-update || {
            echo "Retry pod install after cleanup..."
            rm -rf Pods
            pod cache clean --all || true
            pod install --repo-update
          }

      - name: Validate signing secrets
        shell: bash
        env:
          IOS_CERT_P12: ${{ secrets.IOS_CERT_P12 }}
          IOS_PROVISION_PROFILE: ${{ secrets.IOS_PROVISION_PROFILE }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
          APPLE_APP_STORE_CONNECT_KEY_ID: ${{ secrets.APPLE_APP_STORE_CONNECT_KEY_ID }}
          APPLE_APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APPLE_APP_STORE_CONNECT_ISSUER_ID }}
          APPLE_APP_STORE_CONNECT_KEY: ${{ secrets.APPLE_APP_STORE_CONNECT_KEY }}
        run: |
          set -euo pipefail
          for v in IOS_CERT_P12 IOS_PROVISION_PROFILE KEYCHAIN_PASSWORD IOS_CERT_PASSWORD APPLE_TEAM_ID BUNDLE_ID APPLE_APP_STORE_CONNECT_KEY_ID APPLE_APP_STORE_CONNECT_ISSUER_ID APPLE_APP_STORE_CONNECT_KEY; do
            if [ -z "${!v}" ]; then
              echo "Missing or empty: $v"
              exit 1
            fi
          done

      - name: Bump build number (CFBundleVersion)
        shell: bash
        env:
          BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
        run: |
          set -euo pipefail
          PLIST="ios/callshieldnative/Info.plist"
          if [ ! -f "$PLIST" ]; then
            echo "Info.plist not found at $PLIST"
            exit 1
          fi
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" "$PLIST" || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $BUILD_NUMBER" "$PLIST"
          echo "CFBundleVersion set to:"
          /usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$PLIST"

      - name: Decode certificate + provisioning profile
        shell: bash
        env:
          IOS_CERT_P12: ${{ secrets.IOS_CERT_P12 }}
          IOS_PROVISION_PROFILE: ${{ secrets.IOS_PROVISION_PROFILE }}
        run: |
          set -euo pipefail
          mkdir -p "$HOME/certs"

          # strip CR/LF/spaces to avoid corrupted decode
          printf '%s' "$IOS_CERT_P12" | tr -d '\n\r ' | base64 --decode > "$HOME/certs/dist.p12"
          printf '%s' "$IOS_PROVISION_PROFILE" | tr -d '\n\r ' | base64 --decode > "$HOME/certs/profile.mobileprovision"

          ls -l "$HOME/certs/dist.p12" "$HOME/certs/profile.mobileprovision"

      - name: Validate p12 password (metadata only)
        shell: bash
        env:
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
        run: |
          set -euo pipefail
          openssl pkcs12 -in "$HOME/certs/dist.p12" -info -noout -passin pass:"$IOS_CERT_PASSWORD"

      - name: Create keychain + import cert/key (robust workaround)
        shell: bash
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$HOME/certs/app-signing.keychain-db"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Make it the default keychain and ensure it is in the search list
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"

          # Extract cert + private key via openssl (bypasses security import pkcs12 flakiness)
          openssl pkcs12 -in "$HOME/certs/dist.p12" -clcerts -nokeys \
            -passin pass:"$IOS_CERT_PASSWORD" -out "$HOME/certs/dist_cert.pem"

          openssl pkcs12 -in "$HOME/certs/dist.p12" -nocerts -nodes \
            -passin pass:"$IOS_CERT_PASSWORD" -out "$HOME/certs/dist_key.pem"

          # Import separately (more deterministic)
          security import "$HOME/certs/dist_cert.pem" -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security
          security import "$HOME/certs/dist_key.pem"  -k "$KEYCHAIN_PATH" -T /usr/bin/codesign -T /usr/bin/security

          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Imported identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

          # Export for next steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Install provisioning profile (reliable UUID)
        shell: bash
        run: |
          set -euo pipefail

          # Decode CMS to plist
          security cms -D -i "$HOME/certs/profile.mobileprovision" > "$HOME/certs/profile.plist"

          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$HOME/certs/profile.plist" 2>/dev/null || true)
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$HOME/certs/profile.plist" 2>/dev/null || true)

          if [ -z "$PROFILE_UUID" ] || [ -z "$PROFILE_NAME" ]; then
            echo "Could not extract provisioning profile UUID/Name"
            head -n 60 "$HOME/certs/profile.plist" || true
            exit 1
          fi

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$HOME/certs/profile.mobileprovision" \
            "$HOME/Library/MobileDevice/Provisioning Profiles/$PROFILE_UUID.mobileprovision"

          echo "Installed provisioning profile UUID: $PROFILE_UUID"
          echo "Installed provisioning profile NAME: $PROFILE_NAME"

          TEAM_ID_IN_PROFILE=$(/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' "$HOME/certs/profile.plist" 2>/dev/null || true)
          APP_ID_IN_PROFILE=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$HOME/certs/profile.plist" 2>/dev/null || true)

          echo "Profile TeamIdentifier: $TEAM_ID_IN_PROFILE"
          echo "Profile application-identifier: $APP_ID_IN_PROFILE"

          # Export to next steps
          echo "PROFILE_UUID=$PROFILE_UUID" >> "$GITHUB_ENV"
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$GITHUB_ENV"

      - name: Fix AppIcon transparency (strip alpha) BEFORE archive (no pip)
        shell: bash
        run: |
          set -euo pipefail

          # Find all AppIcon pngs
          ICONS=()
          while IFS= read -r f; do
            ICONS+=("$f")
          done < <(find ios -path "*AppIcon.appiconset*" -name "*.png" -print)

          if [ "${#ICONS[@]}" -eq 0 ]; then
            echo "No AppIcon PNGs found"
            exit 1
          fi

          if command -v magick >/dev/null 2>&1; then
            echo "Using ImageMagick (magick)..."
          elif command -v convert >/dev/null 2>&1; then
            echo "Using ImageMagick (convert)..."
          else
            echo "ImageMagick not found, installing... (brew)"
            brew install imagemagick
          fi

          # Always flatten every icon to remove alpha
          if command -v magick >/dev/null 2>&1; then
            for f in "${ICONS[@]}"; do
              magick "$f" -background white -alpha remove -alpha off "$f"
            done
          else
            for f in "${ICONS[@]}"; do
              convert "$f" -background white -alpha remove -alpha off "$f"
            done
          fi

          echo "== Verifying AppIcon PNGs have no alpha =="
          for f in "${ICONS[@]}"; do
            ha="$(sips -g hasAlpha "$f" | awk -F': ' '/hasAlpha/ {print $2}' | tr -d '\r')"
            if [ "$ha" = "yes" ]; then
              echo "STILL HAS ALPHA: $f"
              sips -g pixelWidth -g pixelHeight -g hasAlpha "$f" || true
              exit 1
            fi
          done

          echo "All AppIcon PNGs are alpha-free."

      - name: Build iOS (archive)
        working-directory: ${{ env.WORKING_DIRECTORY }}
        shell: bash
        env:
          DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
          BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
        run: |
          trap 'echo "::group::xcodebuild log (tail)"; tail -n 200 "$RUNNER_TEMP/xcodebuild-archive.log" || true; echo "::endgroup::"' ERR
          set -euo pipefail

          mkdir -p build

          IOS_WORKSPACE=$(find ios -maxdepth 2 -name "*.xcworkspace" | head -n 1)
          echo "Using workspace: $IOS_WORKSPACE"

          LOG="$RUNNER_TEMP/xcodebuild-archive.log"

          xcodebuild \
            -workspace "$IOS_WORKSPACE" \
            -scheme "${{ env.IOS_SCHEME }}" \
            -configuration Release \
            -sdk iphoneos \
            -destination 'generic/platform=iOS' \
            -archivePath "$PWD/${{ env.ARCHIVE_PATH }}" \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME" \
            CODE_SIGN_KEYCHAIN="$KEYCHAIN_PATH" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" \
            CURRENT_PROJECT_VERSION="${{ env.BUILD_NUMBER }}" \
            ASSETCATALOG_COMPILER_APPICON_NAME=AppIcon \
            ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS=YES \
            archive | tee "$LOG" | xcpretty
            
      - name: Export IPA
        working-directory: ${{ env.WORKING_DIRECTORY }}
        shell: bash
        env:
          BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
        run: |
          set -euo pipefail
          mkdir -p "${{ env.EXPORT_PATH }}"

          cat > exportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store-connect</string>
            <key>teamID</key><string>${{ secrets.APPLE_TEAM_ID }}</string>

            <key>signingStyle</key><string>manual</string>
            <key>signingCertificate</key><string>Apple Distribution</string>

            <key>provisioningProfiles</key>
            <dict>
              <key>$BUNDLE_ID</key><string>$PROFILE_NAME</string>
            </dict>

            <key>compileBitcode</key><false/>
            <key>uploadSymbols</key><true/>
          </dict>
          </plist>
          EOF

          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
          ls -la "$HOME/Library/MobileDevice/Provisioning Profiles" || true
          /usr/libexec/PlistBuddy -c 'Print :application-identifier' "$HOME/certs/profile.plist" || true
          echo "BUNDLE_ID=$BUNDLE_ID  PROFILE_NAME=$PROFILE_NAME"


          xcodebuild -exportArchive \
            -archivePath "$PWD/${{ env.ARCHIVE_PATH }}" \
            -exportOptionsPlist exportOptions.plist \
            -exportPath "$PWD/${{ env.EXPORT_PATH }}" | xcpretty

      - name: Verify AppIcon in IPA has no alpha (REAL check)
        shell: bash
        run: |
          set -euo pipefail

          IPA_FILE="$(ls "${{ env.EXPORT_PATH }}"/*.ipa | head -1 || true)"
          if [ -z "$IPA_FILE" ]; then
            echo "IPA not found"
            exit 1
          fi

          tmp="$(mktemp -d)"
          unzip -q "$IPA_FILE" -d "$tmp"

          APP_DIR="$(find "$tmp/Payload" -maxdepth 1 -name "*.app" -type d | head -n 1 || true)"
          if [ -z "$APP_DIR" ]; then
            echo "❌ .app not found in IPA"
            exit 1
          fi

          echo "✅ App dir: $APP_DIR"
          ICONS_PLIST="$APP_DIR/Info.plist"

          echo "::group::Info.plist icons keys"
          /usr/libexec/PlistBuddy -c 'Print :CFBundleIcons' "$ICONS_PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c 'Print :CFBundleIconName' "$ICONS_PLIST" 2>/dev/null || true
          echo "::endgroup::"

          # Most iOS icon PNGs end up as AppIcon60x60@2x.png, etc (may vary)
          echo "::group::Searching for icon pngs in app bundle"
          find "$APP_DIR" -maxdepth 2 -iname "*icon*.png" -o -iname "AppIcon*.png" | head -n 200 || true
          echo "::endgroup::"

          # Check alpha on any 1024x1024 png found
          echo "::group::Check 1024x1024 alpha"
          found=0
          while IFS= read -r f; do
            w="$(sips -g pixelWidth "$f" 2>/dev/null | awk -F': ' '/pixelWidth/ {print $2}' | tr -d '\r' || true)"
            h="$(sips -g pixelHeight "$f" 2>/dev/null | awk -F': ' '/pixelHeight/ {print $2}' | tr -d '\r' || true)"
            if [ "$w" = "1024" ] && [ "$h" = "1024" ]; then
              found=1
              echo "Candidate: $f"
              sips -g hasAlpha "$f" || true
            fi
          done < <(find "$APP_DIR" -iname "*.png")

          if [ "$found" -eq 0 ]; then
            echo "ℹ️ No 1024x1024 png found directly (could be only in Assets.car). That's OK."
          fi
          echo "::endgroup::"

      - name: Debug icons inside IPA (extract Assets.car)
        shell: bash
        run: |
          set -euo pipefail

          IPA_FILE="$(ls build/ipa/*.ipa | head -1)"
          rm -rf /tmp/ipa_inspect
          mkdir -p /tmp/ipa_inspect
          unzip -q "$IPA_FILE" -d /tmp/ipa_inspect

          APP_DIR="$(find /tmp/ipa_inspect/Payload -maxdepth 1 -name "*.app" | head -1)"
          echo "APP_DIR=$APP_DIR"
          ls -la "$APP_DIR"

          # Assets.car is the compiled asset catalog
          if [ ! -f "$APP_DIR/Assets.car" ]; then
            echo "❌ Assets.car not found"
            exit 1
          fi

          echo "✅ Found Assets.car"
          # Dump info about renditions (includes app icons)
          xcrun --sdk iphoneos assetutil --info "$APP_DIR/Assets.car" | head -n 200
          
      - name: Upload archive artifact
        uses: actions/upload-artifact@v4
        with:
          name: CallShield-archive
          path: ${{ env.ARCHIVE_PATH }}

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: CallShield-ipa
          path: ${{ env.EXPORT_PATH }}

      - name: Create App Store Connect API key JSON (robust)
        shell: bash
        env:
          KEY_ID: ${{ secrets.APPLE_APP_STORE_CONNECT_KEY_ID }}
          ISSUER_ID: ${{ secrets.APPLE_APP_STORE_CONNECT_ISSUER_ID }}
          ASC_KEY: ${{ secrets.APPLE_APP_STORE_CONNECT_KEY }}
        run: |
          set -euo pipefail

          # Normalizza: se il secret contiene \n letterali, li converte in newline reali
          ASC_KEY_NORM="$(printf '%b' "$ASC_KEY")"

          # Crea JSON valido con newline escapati (\n) usando jq
          jq -n \
            --arg key_id "$KEY_ID" \
            --arg issuer_id "$ISSUER_ID" \
            --arg key "$ASC_KEY_NORM" \
            '{key_id:$key_id, issuer_id:$issuer_id, key:$key}' \
            > api_key.json

          # sanity check (non stampa la key)
          ruby -e 'require "json"; j=JSON.parse(File.read("api_key.json")); abort("missing") unless j["key_id"]&&j["issuer_id"]&&j["key"]; puts "api_key.json OK"'

      - name: Install fastlane
        shell: bash
        run: |
          set -euo pipefail
          sudo gem install fastlane -NV

      - name: Upload to TestFlight
        shell: bash
        run: |
          set -euo pipefail

          IPA_FILE="$(ls "${{ env.EXPORT_PATH }}"/*.ipa | head -1 || true)"
          if [ -z "$IPA_FILE" ]; then
            echo "IPA not found in ${{ env.EXPORT_PATH }}"
            ls -la "${{ env.EXPORT_PATH }}" || true
            exit 1
          fi

          fastlane pilot upload \
            --api_key_path api_key.json \
            --ipa "$IPA_FILE" \
            --skip_waiting_for_build_processing true \
            --changelog "CI build"

      - name: Cleanup (always)
        if: always()
        shell: bash
        run: |
          set +e
          security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          echo "All AppIcon PNGs are alpha-free."
          rm -f api_key.json exportOptions.plist || true
